---
title: "Hierarchical Time Series"
subtitle: "Encuesta de Nacional de Ocupación y Empleo (ENOE)"
author: "Diana Villasana Ocampo"
output:
  html_notebook:
    css: "styless.css"
    code_folding: show
    highlight: tango
    theme: flatly
    toc: true
    toc_depth: 3
    toc_float:
      collapsed: true
---


```{r setup, include=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE, cache.lazy = FALSE, collapse = TRUE, 
                      #class.source = "fold-hide",
                      eval = TRUE
                      )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())
```

```{r, echo = FALSE, results=FALSE, warning=FALSE, message=FALSE}
#Font Stlye
require(showtext)
library(extrafont)
windowsFonts()
```

```{r, echo = FALSE, results=FALSE, eval = TRUE}
# Librerías en el documento
require(dygraphs)
require(hts)
require(data.table)
require(openxlsx)
require(dplyr)
require(kableExtra)
require(knitr)
require(ggpubr)
require(ggplot2)
require(webshot)
require(htmlwidgets)
require(stringr)
require(tibble)
require(tidyr)
require(RColorBrewer)
require(psych)
library(purrr)
```


```{r, echo = FALSE, results='asis', eval=(opts_knit$get('rmarkdown.pandoc.to') == 'latex')}
cat('\\pagebreak')
```


# Introducción   

El método de series temporales jerárquicas es una técnica avanzada utilizada para modelar y predecir datos temporales que exhiben una estructura jerárquica natural.  Su aplicación eficaz puede mejorar significativamente la precisión de los pronósticos y facilitar la toma de decisiones estratégicas en diversas áreas de aplicación, es especialmente útil en situaciones donde los datos se pueden descomponer en múltiples niveles de agregación, como por ejemplo, desplazamientos internos, regiones y país.   


**Componentes Principales**   

1. **Descomposición Jerárquica**: Divide los datos en múltiples series temporales interrelacionadas que se organizan en una estructura de árbol jerárquico. Por ejemplo, los desplazamientos internos pueden descomponerse en desplazamientos internos por región, y a su vez, los desplazamientos internos por región se descomponen por estados.       

2. **Modelado Independiente y Consistente**: Cada serie temporal dentro de la jerarquía se modela de forma independiente utilizando métodos de series temporales tradicionales como ARIMA o métodos más avanzados como modelos de espacio de estado.   

3. **Consistencia Agregada**: Los pronósticos de las series temporales individuales se agregan de manera coherente para generar pronósticos precisos y consistentes en todos los niveles de la jerarquía.   

**Consideraciones Prácticas**

- **Software Especializado**: Utilización de herramientas como `R` (con paquetes como `hts`) o `Python` para implementar y automatizar el método.    
- **Validación y Ajuste**: Validar los modelos en múltiples niveles de la jerarquía y ajustar según sea necesario para mejorar la precisión.     


# Encuesta Nacional de Ocupación y Empleo (`ENOE`)      

La Encuesta Nacional de Ocupación y Empleo (`ENOE`), realizada por el Instituto Nacional de Estadística y Geografía (`INEGI`), es una herramienta esencial para medir la dinámica del mercado laboral en México. Proporciona datos detallados sobre la ocupación, el empleo, el desempleo y otras características relevantes de la población económicamente activa.  

**Objetivos Principales**  

1. **Medición de la Población Económicamente Activa (PEA)**: Identificar la proporción de la población que participa en el mercado laboral, incluyendo tanto a las personas ocupadas como a las desocupadas.  

2. **Análisis del Empleo**: Proporcionar información sobre las características del empleo, incluyendo la naturaleza del trabajo, las condiciones laborales, los sectores económicos y las tasas de empleo formal e informal.   

3. **Evaluación del Desempleo**: Estimar la tasa de desempleo y analizar las características de la población desocupada, incluyendo la duración del desempleo y los esfuerzos de búsqueda de empleo.   

4. **Información Socioeconómica**: Recopilar datos sobre la educación, los ingresos y otras variables socioeconómicas que afectan y son afectadas por el empleo y el desempleo.  
 
**Componentes Principales**    

- **Encuestas Trimestrales**: La ENOE se realiza de manera continua, con resultados publicados trimestralmente, lo que permite un seguimiento cercano de las tendencias laborales.   
- **Cobertura Nacional**: La encuesta abarca todas las entidades federativas de México, ofreciendo una visión comprensiva y detallada del mercado laboral a nivel nacional y regional.    
- **Amplitud de Temas**: Incluye información sobre empleo formal e informal, subempleo, ocupaciones, ingresos, condiciones de trabajo y más.    

**Aplicaciones**    

- `Políticas Públicas`: Los datos de la ENOE son cruciales para la formulación y evaluación de políticas laborales, educativas y económicas.   
- `Investigación Académica`: Proporciona una base de datos rica para estudios sobre el mercado laboral, la economía del trabajo y la sociología del empleo.   
- `Análisis Sectorial`: Ayuda a identificar tendencias y desafíos específicos en distintos sectores económicos, informando decisiones empresariales y gubernamentales.   

**Consideraciones Prácticas**    

- **Acceso a Datos**: Los datos de la ENOE están disponibles públicamente a través del INEGI, facilitando su uso para análisis y estudios detallados.
- **Metodología Rigurosa**: La encuesta sigue estándares metodológicos estrictos, asegurando la calidad y confiabilidad de los datos.
- **Actualización Continua**: La ENOE se actualiza continuamente, permitiendo un monitoreo preciso de las dinámicas laborales a lo largo del tiempo.    

## Diseño conceptual 

La población objetivo de la encuesta está conformada por todos los que residen habitualmente las viviendas seleccionadas. Los instrumentos de captación más importantes son el `Cuestionario Sociodemográfico (CS)` y el `Cuestionario de Ocupación y Empleo (COE)`. La información referente a los hogares y a las características sociodemográficas de los residentes de la vivienda se registra en el `CS`, mientras que el `COE` contiene variables que identifican en primer lugar la condición de actividad y en segundo término preguntas específicas para cada uno de los universos. Es necesario mencionar que el `COE` se levanta a la población de 12 años en adelante, sin embargo, por cuestiones metodológicas del marco de la OCDE se pública para la población de 15 años en adelante.        

## Diseño temporal 

La `ENOE` es una encuesta panel de rotatorio, es decir, tiene una muestra de viviendas dividida en 5 paneles de rotación. De los cuales, rota uno cada trimestre; conservando de esta manera, el 80 por ciento de la muestra entre dos trimestres consecutivos.  Lo que permite llevar a cabo dos importantes actividades: sustituir el marco muestral y cambiar esquema de muestreo.     

Por otra parte, toda la cantidad de información recabada de la misma unidad de muestreo en dos o más periodos consecutivos permitirá teóricamente incrementar la precisión de las estimaciones, principalmente del cambio en ellas.  Cochran (1977) coincide con esto y además establece que, en la obtención de las estimaciones actuales, se gana la misma precisión si se conserva la muestra inicial o se cambia en cada ocasión.    

## Condición de Residencia

Un aspecto relevante por considerar fue identificar la condición de residencia, a quienes de los residentes continuaban viviendo en el hogar o en otros términos a quienes no han estado en un proceso de transición de residencia, así como los ausentes definitivos y a los nuevos residentes. Al respecto, cabe acotar, que el diseño conceptual del Cuestionario Sociodemográfico identifica a quienes ya no se encuentran por haber partido a otro lugar por diversas causas entre éstas por mortalidad (`Ausentes Definitivos`) y distingue quienes son nuevos en lo del mismo hogar por haber arribado de algún lugar otro lugar por diversas causas entre ellas el nacimiento (`Nuevo Residentes`).       


## Motivo de la migración [^1]   

[^1]:(https://www.inegi.org.mx/programas/enoe/15ymas/)  

Los datos son recopilados de la `ENOE`, siendo, la fuente principal de información sobre el mercado laboral mexicano al ofrecer datos de manera trimestral de la fuerza de trabajo, ocupación, la informalidad laboral, la subocupación y desocupación.   

La ENOE inicia su levantamiento en 2005 y se repite en intervalos regulares de tiempo, captando la información a nivel nacional. Este tipo de encuesta permite captar y conocer de mejor manera las características socioeconómicas de la población mexicana de 15 años y más.   

El objetivo del trabajo es implementar y comparar las  diferentes series de tiempo de manera jerárquica y permitir el desglose de las causas de migración.      

## Indicadores 

Tomando las preguntas del cuestionario de las cuales son más de *trescientas bases de datos* con *150 mil casos* a nivel nacional en los diferentes periodos de tiempo.      

Las coberturas geográficas o dominios de estudio para las cuales se generan estimaciones son:    

-	`Ciudad Autorepresentada`   
-	`Entidad Federativa`   
-	`Nacional`   

Se toma como referencia la pregunta `cs_ad_mot` **Motivo de la migración **, en la cual se desglosa en las siguientes categorías.   

- Trabajo     
- Estudio   
- Se casó o unió     
- Se separó o divorció    
- Problemas de salud   
- Reunirse con la familia           
- Inseguridad pública      
- Falleció       
- Otro Motivo       
- No sabe  

De las cuales solo se toman 5 casos para el propósito del presente trabajo.   

**Base de datos**   

Se cargan las bases de datos que contienen los cinco principales motivos de la migración, tomando como referencia los datos del 2005 al 2019.   

- `(detectDates = TRUE)`; las fechas se detectan y se convierten automáticamente en objetos de fecha en R.  

```{r}
T.Trabajo <- read.xlsx(paste0(here::here(), "/Base de datos/Resultados ENOE.xlsx"),
                       sheet = "Trabajo", 
                       colNames = TRUE, detectDates = TRUE)
T.Estudio <- read.xlsx(paste0(here::here(), "/Base de datos/Resultados ENOE.xlsx"), 
                       sheet = "Estudio",
                       colNames = TRUE, 
                       detectDates = TRUE)
T.Union <- read.xlsx(paste0(here::here(), "/Base de datos/Resultados ENOE.xlsx"),
                     sheet = "Union",
                     colNames = TRUE, 
                     detectDates = TRUE)
T.Divorcio <- read.xlsx(paste0(here::here(), "/Base de datos/Resultados ENOE.xlsx"), 
                        sheet = "Divorcio", 
                        colNames = TRUE, 
                        detectDates = TRUE)
T.Familia <- read.xlsx(paste0(here::here(), "/Base de datos/Resultados ENOE.xlsx"), 
                       sheet = "Reunirse con un familiar", 
                       colNames = TRUE, 
                       detectDates = TRUE)
```


Se divide entre la población, debido a que si toman los absolutos de las personas que cambiaron de residencia por alguno de los diferentes motivos de ausencia.  Estos tienden a ser mayores en algunas ciudades, debido se tiene mayor densidad de población.  Permitiendo así la comparabilidad entre ciudades por una razón de cada 1000 personas.   

Se define la función llamada `divide_columns` que toma dos data.frames (`df1` y `df2`). La función:   

- Extrae todas las columnas de df1 y df2 desde la segunda columna en adelante.   
- Usa la función `map2_dfc` del paquete `purrr` para dividir cada par de columnas correspondientes de df1 y df2, multiplicando el resultado por 1000.     
- Se reconstruye el data.frame resultante combinando la primera columna de df1 con las columnas resultantes de la división.   

```{r}
#Población Total  
T.Poblacion <- read.xlsx(paste0(here::here(), "/Base de datos/Resultados ENOE.xlsx"), 
                         sheet = "Población", 
                         colNames = TRUE, 
                         detectDates = TRUE)
# Vector de tiempo
Periodo <- T.Poblacion$Periodo #Se guarda el vector tiempo

#Creamos una función personalizada para dividir los elementos desde la segunda columna en adelante
divide_columns <- function(df1, df2) {
                    df1_cols <- df1[, 2:ncol(df1)]
                    df2_cols <- df2[, 2:ncol(df2)]
                    
                    # Aplicamos la división usando map2
                    result_cols <- map2_dfc(df1_cols, df2_cols, ~ .x / .y * 1000)
                    
                    # Reconstruimos el data.frame con la primera columna de df1 y las columnas resultantes
                    result <- bind_cols(df1[, 1, drop = FALSE], result_cols)
                    result
}

tablas <- ls(pattern = "T.")
for(i in 1:6){
  assign(paste0(tablas[i]), divide_columns(get(paste0(tablas[i])), T.Poblacion))
}
```

```{r, echo = TRUE}
# Todo en un data.frame
mydata <- do.call(cbind.data.frame, list(T.Trabajo,
                                         T.Estudio %>% select(-c("Periodo")) ,
                                         T.Union %>% select(-c("Periodo")) ,
                                         T.Divorcio %>% select(-c("Periodo")) ,
                                         T.Familia %>% select(-c("Periodo"))))
```


```{r, echo=FALSE}
tabla <- head(mydata[1:6])
knitr::kable(tabla,
             digits = 2,
             align = "c", 
             caption = "Tasas de migración por algún motivo de ausencia") %>%
kable_styling(position = "center",                
                bootstrap_options = c("condensed", "responsive", "bordered", "hover"),
                font_size = 10) %>%
kable_classic(full_width = FALSE, html_font = "Century Gothic")
```

A continuación se estructura la jerarquía de los niveles de acuerdo al tipo de desagregación geográfica, en la cual se agrupan las 32 ciudades autorepresentadas en regiones.    
- Se consideraron 5 regiones del país para que los cálculos no fueran tan extensos a la hora de interpretarlos.   

```{r, echo = FALSE}
tabla <- data.frame(Regiones = c(rep("Centro", 7),
                                 rep("Noreste", 5),
                                 rep("Noroeste", 5),
                                 rep("Occidente", 8), 
                                 rep("Sureste", 7)),
                    CVE_Ciudad = c("11", 	"24", 	"01", 	"32", 	"04", 	"14", 	"29", 	
                                   "21", 	"03", 	"06", 	"15", 	"09", 	
                                   "08", 	"19", 	"20", 	"30", 	"18", 	
                                   "12", 	"27", 	"02", 	"05", 	"13", 	"28", 	"22", 	"26", 	
                                   "31", 	"23", 	"07", 	"25", 	"17", 	"10", 	"16"),
                    Ciudad = c("Acapulco", 	"Cuernavaca", 	"México", 	"Pachuca", 	"Puebla", 	"Toluca", 	"Tlaxcala", 	
                               "Durango", 	"Monterrey", 	"San Luis Potosí", 	"Saltillo", 	"Tampico", 	
                               "Chihuahua", 	"Culiacán", 	"Hermosillo", 	"La Paz", 	"Tijuana", 	
                               "Aguascalientes", 	"Colima", 	"Guadalajara", 	"León", 	"Morelia", 	"Querétaro", 	"Tepic", 	"Zacatecas", 	
                               "Cancún", 	"Campeche", 	"Mérida", 	"Oaxaca", 	"Tuxtla Guutiérrez", 	"Veracruz", 	"Villahermosa"))

tabla%>%
kable(align = "c",
      col.names = c("Región", "Clave", "Ciudad"),
      caption= "Estructura general de las regiones") %>%
 kable_styling(full_width = FALSE,
               bootstrap_options = c("condensed", "responsive", "bordered", "hover"),
               font_size = 7,
               position = "center",
               latex_options= "HOLD_position") %>% 
  gsub("font-size: initial !important;", "font-size: 10pt !important;", .) %>%
   gsub("text-align: initial !important;", "text-align: justify !important;", .)
```

## Estructura jerárquica  

Cada uno de estos grupos se desglosan en categorías que están anidadas dentro de las categorías de grupos más grandes como 32 ciudades autorepresentadas y 5 regiones, por lo que se hace una recolección de 160 series de tiempo que siguen una estructura de agregación jerárquica.   

![Esquema Jerárquico](Graficos/Región.jpg){widht=100%,height=100%} 

El número de series en el nivel inferior es de 160 series, por lo que las observaciones en el nivel último sumaran a las observaciones del nivel anterior y así sucesivamente.   

Los 5 motivos de la ausencia se transforman en series de tiempo, para analizarlos cada uno posteriormente. Los datos se convierten en objetos de series temporales (`ts`) utilizando la función `ts`. Cada serie temporal se define con:

- `start = 2005`: El primer año de la serie temporal es 2005.   
- `end = 2019`: El último año de la serie temporal es 2019.   
- `frequency = 4`: La frecuencia de la serie temporal es trimestral (4 trimestres por año).    

```{r, echo = TRUE}
ts.Trabajo <- ts(T.Trabajo %>% select(., c(2:length(.))), start = 2005, end = 2019, frequency = 4)
ts.Estudio <- ts(T.Estudio %>% select(., c(2:length(.))), start = 2005, end = 2019, frequency = 4)
ts.Union <- ts(T.Union %>% select(., c(2:length(.))), start = 2005, end = 2019, frequency = 4)
ts.Divorcio <- ts(T.Divorcio %>% select(., c(2:length(.))), start = 2005, end = 2019, frequency = 4)
ts.Familia <- ts(T.Familia %>% select(., c(2:length(.))), start = 2005, end = 2019, frequency = 4)
```

# Motivo de la ausencia: `Trabajo`

Se analiza cómo caso particular el motivo de la **ausencia por trabajo**, para empezar  familiarizarse con la jerarquización del modelo y posteriormente agregar de manera general los demás motivos expuestos al inicio.     

Utilizando la función `dygraph` permite observar de manera iterativa multiples series de tiempo.     

- `dyRangeSelector()`: Agrega un selector de rango (un control deslizante) que permite al usuario seleccionar un rango de fechas para visualizar en el gráfico.    
- `dyLegend(width = 650)`: Añade una leyenda al gráfico y establece su ancho a 650 píxeles.   
- `dyOptions(colors = RColorBrewer::brewer.pal(32, "Set2"))`: Personaliza los colores de las series en el gráfico utilizando la paleta de colores "Set2" de RColorBrewer, que proporciona una paleta de 32 colores.     
- `dyHighlight(highlightSeriesOpts = list(strokeWidth = 2))`: Permite resaltar las series en el gráfico cuando el usuario pasa el cursor sobre ellas. `strokeWidth = 2` establece el grosor de la línea resaltada a 2 píxeles.     

```{r, fig.width=12, fig.height=10, message=FALSE, warning=FALSE}
G.Trabajo <- dygraph(ts.Trabajo, main = "Trabajo",  ylab = "Migrantes", xlab = "Periodo") %>%
              dyRangeSelector() %>%
               dyLegend(width = 650) %>%
                dyOptions(colors = RColorBrewer::brewer.pal(32, "Set2")) %>%
                 dyHighlight(highlightSeriesOpts = list(strokeWidth = 2))
G.Trabajo
```

```{r, out.width= "110%", fig.align='center',fig.cap= "Motivo de trabajo", eval = FALSE, echo = FALSE}
knitr::include_graphics("Graficos/Grafico Trabajo.png")
```

A continuación, se presenta de manera desagregada un análisis descriptivo de las 32 ciudades autorepresentadas.  

```{r,fig.align='center', echo = FALSE}
tabla <- mydata[, grepl("Trabajo", names(mydata))]

kable(describe(tabla),
      digits = 2,
       caption = "Análisis descriptivo: Motivo de trabajo") %>%
 kable_styling(full_width = FALSE, 
               bootstrap_options = c("striped", "condensed"),
               font_size = 8,
               position = "center",
               latex_options= "HOLD_position") %>%
  kable_classic(full_width = F, html_font = "Century Gothic") %>% 
   gsub("font-size: initial !important;", "font-size: 10pt !important;", .) %>%
    gsub("text-align: initial !important;", "text-align: justify !important;", .)
```

**Ejemplo**: Por causas de trabajo la ciudad de Acapulco muestra una media de 4.62 personas que emigraron por trabajo de cada 1000 personas.   

## Serie de tiempo jerárquica   

Se utiliza la función `hts` para crear una serie de tiempo jerárquica. 

**Definición de vectores**:  

- `Regiones`: Un vector que contiene códigos de regiones repetidos para crear una etiqueta de región específica.  
- `Ciudades`: Un vector que contiene códigos de ciudades que se combinan con las regiones para crear nombres únicos.  
- `Motivo`: Un vector que contiene el motivo "Trabajo", repetido para igualar la longitud de los otros vectores.   

**Creacion del nombre de columnas**  

Se utilizan los datos de último nivel y se utiliza el argumento `characters` donde los primeros dos caracteres corresponden al primer nivel (`Región`), los siguientes dos corresponden al segundo nivel (`Ciudades`) y como último los siete caracteres corresponden al motivo de la ausencia (`Trabajo`).   

- `hts(ts.Trabajo, nodes = list(32), characters = c(2, 2, 7))`: Crea un modelo jerárquico de series temporales (`hts`) a partir de ts.Trabajo.    
- `nodes = list(32)`: Define un solo nivel en la jerarquía (`nivel 1`) con 32 nodos.     
- `characters = c(2, 2, 7)`: Define la estructura de los nombres de las columnas en términos de caracteres para la `región(2)`, `ciudad(2)` y `motivo(7)`.    
- `Modelo1$labels$Level 1 <- c("Centro", "Noreste", "Noroeste", "Sureste", "Occidente")`: Asigna etiquetas a los nodos en el *nivel 1* del modelo Modelo1. Estas etiquetas representan diferentes regiones o áreas geográficas en lugar de los códigos originales.     


```{r, echo =TRUE}
#Cambiamos los nombres de las columnas 
Regiones <- c(rep("CE", 7),
              rep("NE", 5), 
              rep("NW", 5), 
              rep("WE", 8),
              rep("SO", 7))
Ciudades <- c("11", 	"24", 	"01",  "32", 	"04", 	"14", 	"29", 	
              "21", 	"03", 	"06", 	"15", 	"09", 	
              "08", 	"19", 	"20", 	"30", 	"18", 	
              "12", 	"27", 	"02", 	"05", 	"13", 	"28", 	"22", 	"26", 	
              "31", 	"23", 	"07", 	"25", 	"17", 	"10", 	"16")
Motivo <- c(rep("Trabajo", 32))

nombres <- paste0(Regiones, Ciudades, Motivo) ## Largo de 11 /Regiones=2,Ciudades=2,Motivo=7
colnames(ts.Trabajo) <- nombres

#Nodos 
Modelo1 <- hts(ts.Trabajo, nodes = list(32), characters = c(2, 2, 7))

## Cambiamos las etiquetas 
Modelo1$labels$`Level 1` <- c("Centro", "Noreste", "Noroeste", "Sureste", "Occidente")
```


```{r, echo = TRUE}
class(Modelo1)
summary(Modelo1)
#p<-smatrix(Modelo1) #Resumen de la matriz de hierarquical time series
#q<-allts(Modelo1) #Matrix de todos los niveles
```

## Nivel 1: Región 

Se visualizan las series temporales agregadas de un modelo jerárquico de series temporales (`Modelo1`).   

- `aggts(level = 1)`: Extrae las series temporales agregadas del nivel 1 del modelo Modelo1. El `level = 1 `indica que se está extrayendo datos del nivel más alto en la jerarquía.      


```{r, echo = TRUE}
Modelo1 %>% 
 aggts(level = 1) %>%
  autoplot(size = 1) + 
   theme_classic() + 
    theme(plot.title = element_text(size = 20),
          plot.subtitle = element_text(size = 12),
          legend.text = element_text(size = 8),
          legend.key.size = unit(0.5, "lines")) +
     scale_color_viridis_d() + 
      scale_color_manual(values = RColorBrewer::brewer.pal(5, "Dark2")) + 
       scale_x_continuous(breaks = seq(2005, 2019, by = 3)) +
        labs(title = "Motivo de la ausencia 2005-2019",
             subtitle = "Trabajo",
             y = "Rate",
             x =  "Year",
             color = "Series") 
```

La gráfica superior muestra la tasa de migración por trabajo total por región. Donde se puede apreciar que la región Noreste y Noroeste presentan una menor moivilidad con respecto a las demás. 


## Nivel 2: Ciudad autorepresentada

A continuación se muetran los datos desglosados por las 32 ciudades. 

- `aggts(level = 2)`: indica que se están extrayendo datos de un nivel de jerarquía inferior al nivel 1.  

```{r}
Modelo1 %>% 
 aggts(level = 2) %>%
  autoplot(size = 0.5) + 
   theme_classic() + 
    theme(plot.title = element_text(size = 20, family = "Century Gothic"),
          plot.subtitle = element_text(size = 12, family = "Century Gothic"),
          legend.text = element_text(size = 8, family = "Century Gothic"),
          legend.spacing.x = unit(0.1, "cm"),
          legend.key.size = unit(0.5, "lines"),
          legend.position = "bottom") +
     scale_color_manual(values = colorRampPalette(brewer.pal(8, "Dark2"))(60)) + 
      guides(col = guide_legend(ncol = 15)) +
       labs(title = "Motivo de la ausencia 2005-2019",
            subtitle = "Trabajo",
            y = "Rate",
            x = "Year",
            color = "Series") 
```

Si bien la gráfica anterior no permite su interpretabilidad debido a que todo el ensamble de las series están muy juntas. 

Haciendo uso de la función `aggts` extrae las series temporales de un objeto `hts` para cualquier nivel de desagregación. Para `aggts(Modelo1, level = 2)`, se especifica que queremos extraer las series temporales del nivel 2 del modelo jerárquico. Los niveles en un modelo jerárquico corresponden a diferentes niveles de agregación en la jerarquía de datos.   

Para este caso, se están trabajando con dos niveles de desagregación (Regiones y Ciudades) y bien un Nivel Cero (Total).   

```{r, echo = TRUE}
groups <- aggts(Modelo1, level = 2)
```

En el siguiente gráfico se muestran las series de tiempo del nivel inferior, es decir, las tasas de migración por trabajo para cada una de las ciudades en sus respectivas regiones.    

Ayudando así a visualizar de manera individual las series.    

```{r, fig.width = 8, fig.height = 5}
tibble::as_tibble(groups) %>%
 tidyr::gather(Series) %>%
  mutate(Date = rep(time(groups), NCOL(groups)),
         Group = stringr::str_extract(Series, "([A-Za-z ]*)")) %>%
   ggplot(aes(x = Date, y = value, group = Series, colour = Series)) +
    geom_line() + 
     theme_classic() +
      theme(plot.title = element_text(size = 20, family = "Century Gothic"),
            plot.subtitle = element_text(size = 12, family = "Century Gothic"),
            axis.text.x = element_text(angle = 90, hjust = 1, family = "Century Gothic"),
            legend.text = element_text(size = 8, family = "Century Gothic"),
            legend.spacing.x = unit(0.1, "cm"),
            legend.key.size = unit(0.5, "lines"),
            legend.position = "bottom") +
       scale_color_viridis_d() + 
       #scale_color_manual(values = colorRampPalette(brewer.pal(8, "Set2"))(33)) + 
        scale_x_continuous(breaks = seq(1980, 2015, by = 5)) +
         scale_y_continuous(labels = scales::comma) +
          guides(col = guide_legend(ncol = 15)) +
           labs(title = "Motivo de la ausencia 2005-2019",
                subtitle = "Trabajo",
                y = "Rate",
                x = "Year",
                color = "Grupos") +
            facet_wrap(. ~ Group)
```

## Forecasting: Motivo de trabajo

Utilizando la función `forecast()` del paquete `hts`.  

Se presentan tres opciones integradas para producir pronósticos usando el parámetro `fmethod`: 

- **ETS** `Exponential Smoothing`,   
- Modelos `ARIMA` 
- Caminatas aleatorias(`RW`).     

### Enfoques [^2]
[^2]:(Forecasting Hierarchical Time Series using R - Brillio Data Science - Medium. (n.d.). Retrieved March 31, 2020, from https://medium.com/brillio-data-science/forecasting-hierarchical-time-series-using-r-598828dba435)

- *Enfoque de abajo hacia arriba* **"bottom-up"**(`method= "bu"`): Pronostica del nivel más bajo de la jerarquía, es decir, los motivos de ausencia y luego va agregando los resultados a la jerárquía generar el pronostico del nivel superior al último.   

- *Enfoque de arriba hacia abajo* **"top-down"** (`method= "tdfp"`): Pronostica en la jerarquía del nivel más alto, es decir, por regiones y luego va desglosando los resultados en la jerarquía.    

- *Enfoque intermedio* **"middle-out" (`method= "mo"`): Combina enfoques ascendentes y descendentes. Primero, se elige un "nivel medio" y se generan pronósticos para todas las series en este nivel. Para las series por encima del nivel medio, se generan pronósticos coherentes utilizando el enfoque de abajo hacia arriba agregando los pronósticos de "nivel medio" hacia arriba. Para las series por debajo del "nivel medio", se generan pronósticos coherentes utilizando un enfoque de arriba hacia abajo al desglosar los pronósticos de "nivel medio" hacia abajo.        
- `method = "tdfp"`: Especifica el método de pronóstico a utilizar. "tdfp" se refiere a "top-down forecasting using a detailed forecast procedure". Este método realiza el pronóstico a nivel más detallado primero y luego agrega los pronósticos hacia los niveles superiores de la jerarquía.    
- `h = 4`: Define el horizonte de pronóstico. En este caso, se está pronosticando 4 períodos hacia el futuro.    
- `keep.fitted = TRUE`: Mantiene los valores ajustados del modelo para su análisis posterior, lo cual puede ser útil para evaluar el rendimiento del modelo.    

```{r, echo = TRUE}
#h<<-forecast horizon
#method= "mo"<<-"middle-out"
f.modelo1 <- forecast(Modelo1, h = 4, method = "tdfp", fmethod = "ets", parallel = TRUE, keep.fitted = TRUE)
```

```{r,echo = TRUE}
class(f.modelo1)
#summary(f.modelo1)
```

### Nivel 0 al 2    

Se extraen las series temporales para los niveles 0, 1 y 2 tanto del modelo de pronóstico (`fcst1`) como del modelo original (`groups`). Esto te permitirá comparar los datos originales con los pronósticos generados a diferentes niveles de la jerarquía.    
- `levels = 0:2`: Especifica que se deben extraer las series temporales para los niveles 0, 1 y 2 del modelo jerárquico.    

```{r,echo = TRUE}
fcst1 <- aggts(f.modelo1, levels = 0:2)
groups <- aggts(Modelo1, levels = 0:2)
```

Se visualizan tanto las series temporales pronosticadas (fcst1) como las series temporales originales (groups).   

```{r,fig.width = 8,fig.height = 5}
autoplot(fcst1, size = 0.5) +
 autolayer(groups) +
  geom_vline(xintercept = 2019, color = "#A8ABD7", linetype= "dashed") +
   theme_classic() +
    theme(plot.title = element_text(size = 18, family = "Century Gothic"),
          plot.subtitle = element_text(size = 14, family = "Century Gothic"),
          legend.text = element_text(size = 7, family = "Century Gothic"),
          legend.key.size = unit(0.5, "lines"),
          legend.position = "bottom") +
     scale_color_viridis_d() + 
      scale_x_continuous(breaks = seq(2005, 2025, by = 2)) +
       scale_y_continuous(labels = scales::comma) +
        guides(col = guide_legend(ncol = 15))+
         labs(title = "Motivo de la ausencia 2005-2019",
              subtitle = "Trabajo",
              y = "Rate",
              x = "Year",
              color = "Series") 
```

Ahora bien, se combinan las series temporales originales y los pronósticos en una sola serie temporal, manteniendo la misma frecuencia y punto de partida que las series originales.  

```{r,echo = TRUE}
tabla <- ts(rbind(groups, fcst1), start = start(groups), frequency = 4)
```

### Nivel Total: Por motivo de trabajo   

A continuación se muetran los datos desglosados a nivel Nacional.    

```{r}
#http://www.sthda.com/english/wiki/ggplot2-line-types-how-to-change-line-types-of-a-graph-in-r-software
autoplot(tabla[, "Total"], colour =  "#1720B7", size = 1.2, alpha = 0.6, linetype = "dashed") +
 geom_vline(xintercept = 2019.5, color = "#A8ABD7", linetype = "dashed") +
  theme_classic() +
   scale_x_continuous(breaks = seq(2005, 2025, by = 2)) +
    labs(title = "Motivo de la ausencia 2005-2019",
         subtitle = "Trabajo",
         y = "Rate",
         x =  "Year",
         color = "Series") 
```

```{r,fig.width = 10,fig.height = 5}
as_tibble(tabla[,-1]) %>%
 tidyr::gather(Series) %>%
  mutate(Date = rep(time(tabla), NCOL(tabla)-1),
         Group = str_extract(Series, "([A-Za-z ]*)")) %>%
   ggplot(aes(x = Date, y = value, group = Series, colour = Series)) +
    geom_line() +
     geom_vline(xintercept = 2017, color = "#A8ABD7", linetype = "dashed") +
      theme_classic() + 
       theme(plot.title = element_text(size = 18, family = "Century Gothic"),
             plot.subtitle = element_text(size = 14, family = "Century Gothic"),
             axis.text.x = element_text(angle = 90, hjust = 1, family = "Century Gothic"),
             legend.position = "bottom",
             legend.text = element_text(size = 8, family = "Century Gothic"),
             legend.key.size = unit(0.5, "lines")) +
        scale_color_viridis_d() +
         scale_x_continuous(breaks = seq(1985, 2025, by = 10)) +
          guides(col = guide_legend(ncol = 15))+
           labs(title = "Motivo de la ausencia 2005-2019",
                subtitle = "Trabajo",
                y = "Rate",
                x = "Year",
                color = "Series") +
            facet_wrap(.~Group) 
```

Se extraen las series temporales para los niveles 0, 1 y 2 tanto del modelo de pronóstico (`f.modelo1`). Esto te permitirá comparar los datos originales con los pronósticos generados a diferentes niveles de la jerarquía. 

- `levels = 0:2`: Especifica que se deben extraer las series temporales para los niveles 0, 1 y 2 del modelo jerárquico.      

```{r,eval=FALSE}
f.modelo1 %>% 
 aggts(levels = 0:2) %>%
  autoplot(facet = FALSE) + 
   theme_classic() +
    theme(plot.title = element_text(size = 18, family = "Century Gothic"),
          plot.subtitle = element_text(size = 14, family = "Century Gothic"),
          legend.text = element_text(size = 7, family = "Century Gothic"),
          legend.key.size = unit(0.5, "lines")) +
     scale_color_viridis_d() +
      labs(title = "Motivo de la ausencia 2005-2019",
           subtitle = "Trabajo",
           y = "Rate",
           x = "Year",
           color = "Series")
```

# Motivos de ausencia en general

Utilizando los 5 motivos de ausencia: 
- Trabajo     
- Estudio   
- Se casó o unió     
- Se separó o divorció    
- Reunirse con la familia  

**Serie de tiempo**  

Los datos de la estructura general se convierten en objetos de series temporales (`ts`) utilizando la función `ts`. Cada serie temporal se define con:    

- `start = 2005`: El primer año de la serie temporal es 2005.   
- `end = 2019`: El último año de la serie temporal es 2019.   
- `frequency = 4`: La frecuencia de la serie temporal es trimestral (4 trimestres por año).   

```{r, echo = TRUE}
ts.mydata <- ts(mydata %>% select(., c(2:ncol(.))), start = 2005, end = 2019, frequency = 4)
```

## Series de tiempo por motivos de la migración   

### Motivo de trabajo  

```{r, fig.width=12, fig.height=10, message=FALSE, warning=FALSE}
G.Trabajo <- dygraph(ts.Trabajo, main = "Trabajo", ylab = "Migrantes", xlab = "Periodo") %>%
              dyRangeSelector() %>%
               dyLegend(width = 650) %>%
                dyOptions(colors = RColorBrewer::brewer.pal(32, "Set2")) %>%
                 dyHighlight(highlightSeriesOpts = list(strokeWidth = 2))
G.Trabajo
```

```{r,out.width= "100%", fig.align='center',fig.cap= "Motivo: Trabajo", eval = FALSE, echo = FALSE}
knitr::include_graphics("Graficos/Grafico Trabajo.png")
```


### Motivo de estudio   

```{r, fig.width=12, fig.height=10, message=FALSE, warning=FALSE}
G.Estudio <- dygraph(ts.Estudio, main = "Estudio", ylab = "Migrantes", xlab = "Periodo") %>%
              dyRangeSelector() %>%
               dyLegend(width = 650) %>%
                dyOptions(colors = RColorBrewer::brewer.pal(32, "Set2")) %>%
                 dyHighlight(highlightSeriesOpts = list(strokeWidth = 2))
G.Estudio
```

```{r,out.width= "100%", fig.align='center',fig.cap= "Motivo: Estudio", eval = FALSE, echo = FALSE}
knitr::include_graphics("Graficos/Grafico Estudio.png")
```

```{r, fig.align='center', echo = FALSE}
tabla <- mydata[, grepl("Estudio", names(mydata))]

kable(describe(tabla),
      digits = 2,
      caption = "Analisis descriptivo: Estudio") %>%
 kable_styling(full_width = FALSE,
               bootstrap_options = c("condensed", "responsive", "bordered", "hover"),
               font_size = 7,
               position = "center",
               latex_options= "HOLD_position") %>% 
  gsub("font-size: initial !important;", "font-size: 10pt !important;", .) %>%
   gsub("text-align: initial !important;", "text-align: justify !important;", .)
```

### Motivo se unió o casó     


```{r, fig.width=12, fig.height=10, message=FALSE, warning=FALSE}
G.Union <- dygraph(ts.Union, main = "Se unió o casó", ylab = "Migrantes", xlab = "Periodo") %>%
            dyRangeSelector() %>%
             dyLegend(width = 650) %>%
              dyOptions(colors = RColorBrewer::brewer.pal(32, "Set2")) %>%
               dyHighlight(highlightSeriesOpts = list(strokeWidth = 2))
G.Union
```

```{r,out.width= "100%", fig.align='center',fig.cap= "Motivo: Se unió o casó", eval = FALSE, echo = FALSE}
knitr::include_graphics("Graficos/Grafico Union.png")
```



```{r,fig.align='center', echo = FALSE}
tabla <- mydata[, grepl("Union", names(mydata))]

kable(describe(tabla),
      digits = 2,
      caption = "Analisis descriptivo: Se unió o casó") %>%
 kable_styling(full_width = FALSE,
               bootstrap_options = c("condensed", "responsive", "bordered", "hover"),
               font_size = 7,
               position = "center",
               latex_options= "HOLD_position") %>% 
  gsub("font-size: initial !important;", "font-size: 10pt !important;", .) %>%
   gsub("text-align: initial !important;", "text-align: justify !important;", .)
```


### Motivo se dicorció o separó   

```{r, fig.width=12, fig.height=10, message=FALSE, warning=FALSE}
G.Divorcio <- dygraph(ts.Divorcio, main = "Se dicorció o separó", ylab = "Migrantes", xlab = "Periodo") %>%
               dyRangeSelector() %>%
                dyLegend(width = 650) %>%
                 dyOptions(colors = RColorBrewer::brewer.pal(32, "Set2")) %>%
                  dyHighlight(highlightSeriesOpts = list(strokeWidth = 2))
G.Divorcio
```

```{r,out.width= "100%", fig.align='center',fig.cap= "Motivo: Se separó o divorció", eval = FALSE, echo = FALSE}
knitr::include_graphics("Graficos/Grafico Divorcio.png")
```

```{r,fig.align='center', echo = FALSE}
tabla <- mydata[, grepl("Divorcio", names(mydata))]

kable(describe(tabla),
      digits = 2,
      caption = "Analisis descriptivo: Se separó o divorció") %>%
 kable_styling(full_width = FALSE,
               bootstrap_options = c("condensed", "responsive", "bordered", "hover"),
               font_size = 7,
               position = "center",
               latex_options= "HOLD_position") %>% 
  gsub("font-size: initial !important;", "font-size: 10pt !important;", .) %>%
   gsub("text-align: initial !important;", "text-align: justify !important;", .)
```


### Motivo para reunirse con un familiar  
 
```{r, fig.width=12, fig.height=10, message=FALSE, warning=FALSE}
G.Familiar <- dygraph(ts.Familia, main = "Reunirse con un familiar", ylab = "Migrantes", xlab = "Periodo") %>%
               dyRangeSelector() %>%
                dyLegend(width = 650) %>%
                 dyOptions(colors = RColorBrewer::brewer.pal(32, "Set2")) %>%
                  dyHighlight(highlightSeriesOpts = list(strokeWidth = 2))
G.Familiar
```

```{r,out.width= "100%", fig.align='center',fig.cap= "Motivo: Reunirse con un familiar", eval = FALSE, echo = FALSE}
knitr::include_graphics("Graficos/Grafico Familiar.png")
```

```{r, fig.align='center', echo = FALSE}
tabla <- mydata[, grepl("Familiar", names(mydata))]

kable(describe(tabla),
      digits = 2,
      caption = "Analisis descriptivo: Reunirse con un familiar") %>%
  kable_styling(full_width = FALSE,
                bootstrap_options = c("striped"),
                font_size = 7,
                position = "center",
                latex_options= "HOLD_position")
```

```{r,eval=FALSE, echo = FALSE}
#https://github.com/rstudio/dygraphs/issues/71
saveWidget(G.Trabajo, "Grafico Trabajo.html", selfcontained = TRUE, libdir = NULL)
saveWidget(G.Estudio, "Grafico Estudio.html", selfcontained = TRUE, libdir = NULL)
saveWidget(G.Union, "Grafico Union.html", selfcontained = TRUE, libdir = NULL)
saveWidget(G.Divorcio, "Grafico Divorcio.html", selfcontained = TRUE, libdir = NULL)
saveWidget(G.Familiar, "Grafico Familiar.html", selfcontained = TRUE, libdir = NULL)

width<- 1080
height <- 610
#Se convierten de html a .pdf
webshot(url = "Grafico Trabajo.html", file = "Grafico Trabajo.png",
        cliprect = c(10, 30, width + 50, height + 50),
        vwidth = width, 
        vheight = height)
webshot(url = "Grafico Estudio.html", file = "Grafico Estudio.png",
        cliprect = c(10, 30, width + 50, height + 50),
        vwidth = width, 
        vheight = height)
webshot(url = "Grafico Union.html", file = "Grafico Union.png",
        cliprect = c(10, 30, width + 50, height + 50),
        vwidth = width, 
        vheight = height)
webshot(url = "Grafico Divorcio.html", file = "Grafico Divorcio.png",
        cliprect = c(10, 30, width + 50, height + 50),
        vwidth = width, 
        vheight = height)
webshot(url = "Grafico Familiar.html",file = "Grafico Familiar.png",
        cliprect = c(10, 30, width + 50, height + 50),
        vwidth = width, 
        vheight = height)
``` 

## Modelo jerárquico

Se utiliza la función `hts()` para crear una serie de tiempo jerárquica. 

Donde se utilizan los datos de último nivel y se utiliza el argumento `characters` donde los primeros dos caracteres corresponden al primer nivel (Región), los siguientes dos corresponden al segundo nivel (Ciudades) y como último los tres caracteres corresponden al motivo de la ausencia.   

- `TRA` = "Trabajo"   
- `EST` = "Estudio"   
- `UNI` = "Se casó o unió"   
- `DIV` = "Se divorció o separó"    
- `FAM` = "Reunirse con un familiar"   

**Definición de vectores:**   

- `Regiones`: Un vector que contiene códigos de regiones repetidos para crear una etiqueta de región específica.
- `Ciudades`: Un vector que contiene códigos de ciudades que se combinan con las regiones para crear nombres únicos.
- `Motivo`: Un vector que contiene el motivo de la ausencia, repetido para igualar la longitud de los otros vectores.   

```{r,echo = TRUE}
Regiones <- rep(c(rep("CE", 7),
                  rep("NE", 5),
                  rep("NW", 5),
                  rep("WE", 8),
                  rep("SO", 7)), 5)
Ciudades <- rep(c("11", 	"24", 	"01", 	"32", 	"04", 	"14", 	"29",
                  "21", 	"03", 	"06", 	"15", 	"09",
                  "08", 	"19", 	"20", 	"30", 	"18", 	
                  "12", 	"27", 	"02", 	"05", 	"13", 	"28", 	"22", 	"26", 	
                  "31", 	"23", 	"07", 	"25", 	"17", 	"10", 	"16"), 5)

Motivo <- c(rep("TRA", 32),
            rep("EST", 32),
            rep("UNI", 32),
            rep("DIV", 32),
            rep("FAM", 32))

nombres <- paste0(Regiones, Ciudades, Motivo) #Largo de 7 | Regiones=2|Ciudades=2|Motivo=3
colnames(ts.mydata) <- nombres

nodes <- list(160, c(5, 32, 5)) #160 variables |Regiones=5|Ciudades=32|Motivos=5|  
Modelo2 <- hts(ts.mydata, nodes = nodes,characters = c(2, 2, 3))

#Cambiamos los labels 
Modelo2$labels$`Level 1` <- c("Centro", "Noreste", "Noroeste", "Sureste", "Occidente")
```

### Nivel 1: Región   

Se visualizan las series temporales agregadas de un modelo jerárquico de series temporales (`Modelo1`).   

- `aggts(level = 1)`: Extrae las series temporales agregadas del nivel 1 del modelo Modelo1. El `level = 1 `indica que se está extrayendo datos del nivel más alto en la jerarquía.       

```{r}
Modelo2 %>% 
 aggts(level = 1) %>%
  autoplot(size = 1) + 
   theme_classic() + 
    theme(plot.title = element_text(size = 20),
          plot.subtitle = element_text(size = 12),
          legend.text = element_text(size = 8),
          legend.key.size = unit(0.2, "cm")) +
     scale_color_viridis_d() + 
      scale_color_manual(values = RColorBrewer::brewer.pal(5, "Dark2")) + 
       scale_x_continuous(breaks = seq(2005, 2019, by = 2)) +
        labs(title = "Motivo de la ausencia 2005-2019",
             subtitle = "Trabajo / Estudio / Se casó o unió / Divorció o separó / Reunirse con un familiar",
             y = "Rate",
             x = "Year",
             color = "Series") 
```

## Nivel 2: Cuidad autorepresentada    

A continuación se muetran los datos desglosados por las 32 ciudades. 

- `aggts(level = 2)`: indica que se están extrayendo datos de un nivel de jerarquía inferior al nivel 1.  

```{r}
Modelo2 %>% 
 aggts(level = 2) %>%
  autoplot(size = 0.5) + 
   theme_classic() + 
    theme(plot.title = element_text(size = 20),
          plot.subtitle = element_text(size = 12),
          legend.text = element_text(size = 8),
          legend.key.size = unit(0.5, "lines"),
          legend.position = "bottom") +
     scale_color_manual(values = colorRampPalette(brewer.pal(8, "Dark2"))(60)) + 
      guides(col = guide_legend(ncol = 15))+
       labs(title = "Motivo de la ausencia 2005-2019",
            subtitle = "Trabajo / Estudio / Se casó o unió / Divorció o separó / Reunirse con un familiar",
            y = "Rate",
            x = "Year",
            color = "Series") 
```

Si bien la gráfica anterior no permite su interpretabilidad debido a que todo el ensamble de las series están muy juntas. 

Haciendo uso de la función `aggts` extrae las series temporales de un objeto `hts` para cualquier nivel de desagregación. Para `aggts(Modelo1, level = 2)`, se especifica que queremos extraer las series temporales del nivel 2 del modelo jerárquico. Los niveles en un modelo jerárquico corresponden a diferentes niveles de agregación en la jerarquía de datos. 

Para este caso, se están trabajando con dos niveles de desagregación (Regiones y Ciudades) y bien un Nivel Cero (Total).   

```{r,echo = TRUE}
groups <- aggts(Modelo2, level = 2)
```

```{r,fig.width = 10,fig.height = 12}
tibble::as_tibble(groups) %>%
 tidyr::gather(Series) %>%
  mutate(Date = rep(time(groups), NCOL(groups)),
         Group =stringr::str_extract(Series, "([A-Za-z ]*)")) %>%
   ggplot(aes(x = Date, y = value, group = Series, colour = Series)) +
    geom_line() + 
     theme_classic() +
      theme(plot.title = element_text(size = 20),
            plot.subtitle = element_text(size = 12),
            axis.text.x = element_text(angle = 90, hjust = 1),
            legend.text = element_text(size = 8),
            legend.key.size = unit(0.5, "lines"),
            legend.position = "bottom") +
       scale_color_viridis_d() +
       #scale_color_manual(values = colorRampPalette(brewer.pal(8, "Dark2"))(33)) + 
        scale_x_continuous(breaks = seq(1980, 2015, by = 5)) +
         scale_y_continuous(labels = scales::comma) +
          guides(col = guide_legend(ncol = 15))+
           labs(title = "Motivo de la ausencia 2005-2019",
                subtitle = "Trabajo / Estudio / Se casó o unió / Divorció o separó / Reunirse con un familiar",
                y = "Rate",
                x = "Year",
                color = "Series") +
            facet_wrap(. ~ Group) 
```

## Nivel 3: Motivo de la ausencia    

Haciendo uso de la función `aggts` extrae las series temporales de un objeto `hts` para cualquier nivel de desagregación. Para `aggts(Modelo2, level = 3)`, se especifica que queremos extraer las series temporales del nivel 23 del modelo jerárquico. Los niveles en un modelo jerárquico corresponden a diferentes niveles de agregación en la jerarquía de datos. 

En modelo general, se están trabajando con tres niveles de desagregación (`Motivo de ausencia`, `Regiones` y `Ciudades`) y bien un Nivel Cero (`Total`).    

```{r,echo = TRUE}
groups <- aggts(Modelo2, level = 3)
```

```{r,fig.width = 10,fig.height = 12}
#https://stringr.tidyverse.org/reference/str_locate.html
tibble::as_tibble(groups) %>%
 tidyr::gather(Series) %>% 
  mutate(Date = rep(time(groups), NCOL(groups)),
         Group =stringr::str_extract(Series, "([A-Za-z ]*)"),
         Motivo=stringr::str_sub(Series,5, 7)) %>%
   ggplot(aes(x = Date, y = value, group = Series, colour = Series)) +
    geom_line() + 
     theme_classic() +
      theme(plot.title = element_text(size = 20),
            plot.subtitle = element_text(size = 12),
            axis.text.x = element_text(angle = 90, hjust = 1),
            legend.text = element_text(size = 8),
            legend.key.width=unit(0.2, "cm"),
            legend.key.height = unit(0, "cm"),
            legend.spacing.x = unit(0, "cm"),
            legend.key.size = unit(0.5, "lines"),
            legend.position = "bottom") +
       scale_color_viridis_d() +
       #scale_color_manual(values = colorRampPalette(brewer.pal(8, "Dark2"))(160)) + 
        scale_x_continuous(breaks = seq(1980, 2015, by = 5)) +
         scale_y_continuous(labels = scales::comma) +
          guides(col = guide_legend(ncol = 15))+
           labs(title = "Motivo de la ausencia 2005-2019",
                subtitle = "Trabajo / Estudio / Se casó o unió / Divorció o separó / Reunirse con un familiar",
                y = "Rate",
                x = "Year",
                color = "Series") +
            facet_wrap(. ~ Group + Motivo) 
```

Analizando la gráfica anterior el motivo de ausencia para "Reunirse con un familiar" es la que presenta un mayor número de casos migratorios" con respecto a los otros cuatro casos.      

```{r}
#print(Modelo2)
#smatrix(Modelo2)
#allts(Modelo2)
```

## Forecasting: Motivo de la ausencia en general   

Se realiza un pronóstico jerárquico sobre `Modelo2` para los próximos 10 periodos, utilizando el método de `"middle-out"` para la agregación jerárquica y el modelo `ARIMA` para los pronósticos individuales.   

Se espera que los pronósticos sean consistentes con la estructura de agregación de las series de  tiempo al agruparlas.    

```{r, echo = TRUE}
#h=forescast horizon
#method<-"mo", "bu", "tdfp"
f.modelo2 <- forecast(Modelo2, h = 10, method = "mo", level = 2, fmethod = "arima", parallel = TRUE, keep.fitted = TRUE)
```

```{r,echo = TRUE, eval = FALSE}
summary(f.modelo2)
```

### Nivel 0 al 2: Total / Región / Ciudad   

Se extraen las series temporales para los niveles 0, 1 y 2 tanto del modelo de pronóstico (`fcst2`) como del modelo original (`groups`). Esto te permitirá comparar los datos originales con los pronósticos generados a diferentes niveles de la jerarquía.     
- `levels = 0:2`: Especifica que se deben extraer las series temporales para los niveles 0, 1 y 2 del modelo jerárquico.  

```{r,echo = TRUE}
fcst2 <- aggts(f.modelo2, levels = 0:2)
groups <- aggts(Modelo2, levels = 0:2)
```

```{r,fig.width = 10, fig.height = 8}
autoplot(fcst2, size = 0.5) +
 autolayer(groups) +
  geom_vline(xintercept = 2019,color = "#A8ABD7", linetype = "dashed") +
   theme_classic() +
    theme(plot.title = element_text(size = 20),
          plot.subtitle = element_text(size = 12),
          legend.text = element_text(size = 7),
          legend.key.size = unit(0.5, "lines"),
          legend.position = "bottom") +
     scale_color_viridis_d() + 
      scale_x_continuous(breaks = seq(2005, 2025, by = 2)) +
       scale_y_continuous(labels = scales::comma) +
        guides(col = guide_legend(ncol = 15))+
         labs(title = "Motivo de la ausencia 2005-2019",
              subtitle = "Trabajo / Estudio / Se casó o unió / Divorció o separó / Reunirse con un familiar",
              y = "Rate",
              x = "Year",
              color = "Series") 
```

Se crea una serie temporal combinada de las series temporales originales y los pronósticos.   

```{r,echo = TRUE}
tabla <- ts(rbind(groups, fcst2),
                  start = start(groups), frequency = 4) #Frecuencia al año
```

### Nivel 0: Total de casos de migración   

A continuación se muetran los datos desglosados a nivel Nacional.  

```{r}
#http://www.sthda.com/english/wiki/ggplot2-line-types-how-to-change-line-types-of-a-graph-in-r-software
autoplot(tabla[, "Total"], colour = "#1720B7", size = 1.2, alpha = 0.6, linetype = "dashed") +      
 geom_vline(xintercept=2019.5,color = "#A8ABD7",linetype= "dashed") +
  theme_classic() +
   theme(plot.title = element_text(size = 20),
         plot.subtitle = element_text(size = 12)) + 
     scale_x_continuous(breaks = seq(2005, 2025, by = 2)) +
     labs(title = "Motivo de la ausencia 2005-2019",
          subtitle = "Trabajo / Estudio / Se casó o unió / Divorció o separó / Reunirse con un familiar",
          y = "Rate",
          x = "Year",
          color = "Series") 
```

### Nivel 1 a 2: Nivel región y nivel ciudad  

A continuación se muetran los datos desglosados a nivel Región.  

```{r,fig.width = 10,fig.height = 5}
as_tibble(tabla[,-1]) %>%
 tidyr::gather(Series) %>%
  mutate(Date = rep(time(tabla), NCOL(tabla)-1),
         Group = str_extract(Series, "([A-Za-z ]*)")) %>%
   ggplot(aes(x = Date, y = value, group = Series, colour = Series)) +
    geom_line() +
     geom_vline(xintercept = 2019,color = "#A8ABD7", linetype = "dashed") +
      theme_classic() + 
       theme(plot.title = element_text(size = 20),
             plot.subtitle = element_text(size = 12),
             axis.text.x = element_text(angle = 90, hjust = 1),
             legend.text = element_text(size = 8),
             legend.key.width = unit(0.2, "cm"),
             legend.key.height = unit(0, "cm"),
             legend.spacing.x = unit(0.1, "cm"),
             legend.key.size = unit(0.5, "lines"),
             legend.position = "bottom") +
        scale_color_viridis_d() +
         scale_x_continuous(breaks = seq(2005, 2025,by = 5)) +
          guides(col = guide_legend(ncol = 15)) +
           labs(title = "Motivo de la ausencia 2005-2019",
                subtitle = "Trabajo / Estudio / Se casó o unió / Divorció o separó / Reunirse con un familiar",
                y = "Rate",
                x = "Year",
                color = "Series") +
            facet_wrap(. ~ Group) 
```

### Nivel 3: Motivos de ausencia en general   v

A continuación se muetran los datos desglosados por motivo de la ausencia.    

```{r,echo = TRUE}
fcst3 <- aggts(f.modelo2, levels = 3)
groups <- aggts(Modelo2, levels = 3)
tabla <- ts(rbind(groups, fcst3), start = start(groups), frequency = 4) #Frecuencia al año
```

```{r, fig.width = 13,fig.height = 13}
as_tibble(tabla[,-1]) %>%
 tidyr::gather(Series) %>%
  mutate(Date = rep(time(tabla), NCOL(tabla) - 1),
         Group = str_extract(Series, "([A-Za-z ]*)"),
         Motivo = stringr::str_sub(Series, 5, 7)) %>%
   ggplot(aes(x = Date, y = value, group = Series, colour = Series)) +
    geom_line() +
     geom_vline(xintercept = 2019, color = "#A8ABD7", linetype= "dashed") +
      theme_classic() + 
       theme(plot.title = element_text(size = 20),
             plot.subtitle = element_text(size = 12),
             axis.text.x = element_text(angle=90, hjust=1),
             legend.text = element_text(size = 6),
             legend.key.width=unit(0.2, "cm"),
             legend.key.height = unit(0, "cm"),
             legend.spacing.x = unit(0.1, "cm"),
             legend.key.size = unit(0.01, "lines"),
             legend.position = "bottom") +
        scale_color_viridis_d() +
         scale_x_continuous(breaks = seq(2005, 2025,by = 5)) +
          guides(col = guide_legend(ncol = 15)) +
           labs(title = "Motivo de la ausencia 2005-2019",
                subtitle = "Trabajo / Estudio / Se casó o unió / Divorció o separó / Reunirse con un familiar",
                y = "Rate",
                x = "Year",
                color = "Series") +
            facet_wrap(.~ Group + Motivo)
```


# Referencias

Athanasopoulos, G, Hyndman, RJ, Kourentzes, N, and Petropoulos, F (2017). Forecasting with Temporal Hierarchies. European Journal of Operational Research 262(1), 60–74.   

Cochran, W.G. (1977), Sampling Techniques. Jonh Wiley and Sons, New York.   

Encuesta Nacional de Ocupación y Empleo (ENOE), población de 15 años y más de edad. (2020). 50 preguntas y respuestas. Instituto Nacional de Estadística Geografía e Informática. Retrieved May 7, 2020, from https://www.inegi.org.mx/programas/enoe/15ymas/default.html#Documentacion   


Forecasting Hierarchical Time Series using R - Brillio Data Science - Medium. (n.d.). Retrieved March 30, 2020, from https://medium.com/brillio-data-science/forecasting-hierarchical-time-series-using-r-598828dba435   

R. J. Hyndman and A. Koehler (2006), Another look at measures of forecast accuracy, International Journal of Forecasting, 22, 679-688.  

Hyndman R.J., Ahmed R.A., Athanasopoulos G., Shang H.L., (2011), Optimal combination forecasts for hierarchical time series, Computational Statistics & Data Analysis 55(9), 2579 -2589.  

Hyndman, R. J., Athanasopoulos, G., & Shang, H. L. (2014). hts: An R Package for Forecasting Hierarchical or Grouped Time Series. https://cran.r-project.org/web/packages/hts/vignettes/hts.pdf?forcedefault=true       

Hyndman, RJ (2017). forecast: Forecasting Functions for Time Series and Linear Models. R package version 8.1. http://pkg.robjhyndman.com/forecast.   

 
# Librerías  

**Librerías que se usaron en el trabajo**   

```{r, echo = FALSE}
names(sessionInfo()$otherPkgs)
```

Nos ha servido a construir modelos de series de tiempo con datos estructurales para fines de pronósticos. 



<a rel= "license" href= "http://creativecommons.org/licenses/by/4.0/"><img src= "https://i.creativecommons.org/l/by/4.0/88x31.png" alt= "Creative Commons Licence" style= "border-width:0"/></a><br />This work by [**Diana Villasana Ocampo**]{xmlns:cc= "http://creativecommons.org/ns#" property = "cc:attributionName"} is licensed under a <a rel= "license" href= "http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.

